# Replication and Sharding

- For more traffic, connections/processing could become too many
- Replicate to handle more requests
- Leader/Follower aka Master/Slave
    - Leader replicates its own data to other followers, which could chain reaction
    - Read/Write to the leader
    - Read from the followers 
    - Simple way to scale up reads
    - Asynchronous replication: At some point replicated to followers, some schedule, some stale data possible
    - Synchronous replication: Immediately replicated to followers, logic could imply including complete replication as part of latency for request completion
    - Replication increases reliability and availability
    - Even if leader goes down, another could take place
- Multi-Leader/Multi-Master/Leader-Leader replication:
    - Scale up reads and writes
    - Replication happens both ways
    - Lower consistency between the nodes
    - Async: losely consistent
    - Sync: Much higher latency
    - Could distribute leaders across vast geographical regions, and asychronously replicate
- Sharding
    - Implementing is hard in practice
    - Vertical scaling has limitation
    - Replication could increase read/write availabilities
    - But massive data would need splitting -> sharding
    - The smaller pieces are called shards
    - Queries will be faster
    - Few approaches to decide how to segment
    - Use Range based shard key, typically use primary key
    - Hash based sharding: consistent hashing
    - Postgres, MySQL do not provide sharding out of box: implement application level sharding
    - NoSQL DBs offer sharding out of the box
    - Compromises ACID principles